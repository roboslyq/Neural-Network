<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI的本质</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
            overflow-x: hidden;
        }
        h1, h2, h3 {
            color: #2c3e50;
            text-align: center;
            margin-top: 10px;
        }
        .main-container {
            display: flex;
            flex-direction: row;
            height: 100vh;
            overflow: hidden;
        }
        .left-panel {
            flex: 3;
            background-color: #f0f7ff;
            border-right: 1px solid #ddd;
            padding: 15px;
            overflow-y: auto;
            height: 100%;
            box-sizing: border-box;
        }
        .middle-panel {
            flex: 2;
            background-color: #f8f9fa;
            border-right: 1px solid #ddd;
            padding: 15px;
            overflow-y: auto;
            height: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        .right-panel {
            flex: 2;
            background-color: #fff8e1;
            padding: 15px;
            overflow-y: auto;
            height: 100%;
            box-sizing: border-box;
        }
        #aiCanvas {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 10px 0;
            background-color: white;
        }
        .explanation {
            background-color: #ffffff;
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.1);
        }
        .key-point {
            font-weight: bold;
            color: #2980b9;
        }
        .demo-input {
            display: flex;
            margin-bottom: 15px;
        }
        .demo-input input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        .demo-input button {
            margin-left: 10px;
            padding: 8px 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .demo-input button:hover {
            background-color: #2980b9;
        }
        .chat-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 300px;
            overflow-y: auto;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }
        .user-message, .ai-message {
            padding: 10px 15px;
            border-radius: 18px;
            max-width: 80%;
        }
        .user-message {
            align-self: flex-end;
            background-color: #dcf8c6;
            text-align: right;
        }
        .ai-message {
            align-self: flex-start;
            background-color: #ffffff;
        }
        .cursor {
            display: inline-block;
            width: 2px;
            height: 18px;
            background-color: #3498db;
            animation: blink 1s infinite;
            vertical-align: middle;
            margin-left: 2px;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        .status-message {
            text-align: center;
            font-weight: bold;
            margin: 10px 0;
            color: #3498db;
            height: 20px;
        }
        .header {
            background-color: #2c3e50;
            color: #ffffff;
            padding: 15px;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0,0,0,0.7);
            border-bottom: 3px solid #3498db;
            margin-bottom: 15px;
        }
        .header h1 {
            font-size: 28px;
            margin: 0;
            color: #ffffff;
            letter-spacing: 1px;
        }
        .subtitle {
            font-size: 16px;
            margin-top: 8px;
            color: #ecf0f1;
            font-weight: 500;
        }
        .controls {
            display: flex;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background-color: #eee;
            border-radius: 5px;
        }
        .controls button {
            padding: 6px 12px;
            margin-right: 10px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .controls button:hover {
            background-color: #2980b9;
        }
        .controls button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        .speed-control {
            display: flex;
            align-items: center;
            margin-left: 15px;
        }
        .speed-control label {
            margin-right: 10px;
            white-space: nowrap;
        }
        .speed-value {
            margin-left: 10px;
            font-weight: bold;
            min-width: 30px;
        }
        .network-phase {
            text-align: center;
            font-weight: bold;
            color: #e74c3c;
            margin: 5px 0;
        }
        .progress-container {
            width: 100%;
            height: 5px;
            background-color: #eee;
            margin-top: 5px;
            border-radius: 3px;
        }
        .progress-bar {
            height: 100%;
            background-color: #3498db;
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s;
        }
        .vocabulary-container {
            margin-top: 0;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        .vocabulary-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #2c3e50;
        }
        .token-probability {
            display: flex;
            margin-bottom: 5px;
            align-items: center;
        }
        .token {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 10px;
            font-weight: bold;
        }
        .probability-bar {
            height: 20px;
            background-color: #3498db;
            border-radius: 3px;
            transition: width 0.3s;
        }
        .probability-value {
            margin-left: 10px;
            font-size: 12px;
            width: 50px;
        }
        .selected-token {
            background-color: #e74c3c;
            color: white;
        }
        #token-probabilities {
            overflow-y: auto;
            flex-grow: 1;
        }
        .vocabulary-panel {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        .probability-section {
            flex: 1;
            overflow-y: auto;
            border-bottom: 1px solid #ddd;
            padding-bottom: 15px;
            margin-bottom: 15px;
        }
        .vocabulary-section {
            height: 250px;
            overflow-y: auto;
            background-color: #f0f0f0;
            border-radius: 5px;
            padding: 10px;
        }
        .vocabulary-section h3 {
            margin-top: 0;
            font-size: 16px;
            color: #2c3e50;
        }
        .vocabulary-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .vocabulary-table th {
            background-color: #e0e0e0;
            padding: 5px;
            text-align: left;
        }
        .vocabulary-table td {
            padding: 5px;
            border-bottom: 1px solid #ddd;
        }
        .vector-cell {
            font-family: monospace;
            color: #666;
            font-size: 10px;
        }
        .feedback-arrow {
            stroke-width: 3;
            filter: drop-shadow(0 0 3px rgba(52, 152, 219, 0.7));
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>深入理解AI的本质</h1>
        <div class="subtitle">可视化大语言模型的工作原理</div>
    </div>
    
    <div class="main-container">
        <!-- 左侧面板：神经网络可视化 -->
        <div class="left-panel">
            <h2>神经网络结构</h2>
            <canvas id="aiCanvas"></canvas>
            <div id="network-phase" class="network-phase"></div>
            <div id="status-display" class="status-message"></div>
            <div class="progress-container">
                <div id="progress-bar" class="progress-bar"></div>
            </div>
            
            <div class="controls">
                <button id="pause-btn" disabled>暂停</button>
                <button id="resume-btn" disabled>继续</button>
                <div class="speed-control">
                    <label for="speed-slider">动画速度:</label>
                    <input type="range" id="speed-slider" min="1" max="10" value="5">
                    <span id="speed-value" class="speed-value">5</span>
                </div>
            </div>
            
            <div class="explanation">
                <h3>AI的本质解析</h3>
                <p>人工智能的核心在于<span class="key-point">模式识别</span>和<span class="key-point">统计学习</span>。上图展示了AI的基本工作原理：</p>
                <ol>
                    <li><strong>数据输入层</strong>：AI接收并处理数据</li>
                    <li><strong>隐藏层</strong>：通过多层神经网络进行特征提取</li>
                    <li><strong>输出层</strong>：产生预测或决策结果</li>
                    <li><strong>反馈循环</strong>：通过不断调整参数学习优化</li>
                </ol>
                <p>大语言模型的本质是<span class="key-point">预测下一个字符/词的概率分布</span>，通过大量文本数据学习语言模式。</p>
                <p>大语言模型的一个关键特性是<span class="key-point">自回归</span>：模型生成的每个新字符都会立即成为预测下一个字符的输入。这种循环过程使模型能够维持上下文连贯性。</p>
                <p>大语言模型的核心机制是<span class="key-point">词汇表和概率分布</span>。模型会：</p>
                <ol>
                    <li>维护一个包含所有可能词汇/字符的词汇表</li>
                    <li>对每个位置，计算词汇表中每个词/字符出现的概率</li>
                    <li>选择概率最高的词/字符作为输出</li>
                    <li>将已生成的内容作为新的输入，重复这个过程</li>
                </ol>
                <p>Transformer架构是现代大语言模型（如GPT-3）的核心架构。它通过自注意力机制捕捉上下文关系，并通过前馈网络处理特征转换。</p>
            </div>
        </div>
        
        <!-- 中间面板：词汇表概率分布 -->
        <div class="middle-panel">
            <h2>词汇表与概率分布</h2>
            
            <div class="vocabulary-panel">
                <!-- 上部分：概率分布 -->
                <div class="probability-section">
                    <p>这里展示了模型如何从词汇表中选择下一个字符。在输出阶段，模型会计算每个候选字符的概率，并选择概率最高的字符作为输出。</p>
                    
                    <div id="vocabulary-container" class="vocabulary-container">
                        <div class="vocabulary-title">词汇表概率分布</div>
                        <div id="token-probabilities"></div>
                    </div>
                </div>
                
                <!-- 下部分：词汇表向量化展示 -->
                <div class="vocabulary-section">
                    <h3>词汇表向量化编码示例</h3>
                    <p>大语言模型将词汇表中的每个词/字符编码为高维向量（嵌入），以捕捉语义信息。</p>
                    
                    <table class="vocabulary-table">
                        <thead>
                            <tr>
                                <th>词/字符</th>
                                <th>ID</th>
                                <th>向量表示（降维后）</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>我</td>
                                <td>1024</td>
                                <td class="vector-cell">[0.32, -0.56, 0.12, 0.78, -0.41, ...]</td>
                            </tr>
                            <tr>
                                <td>你</td>
                                <td>1025</td>
                                <td class="vector-cell">[0.28, -0.42, 0.35, 0.62, -0.18, ...]</td>
                            </tr>
                            <tr>
                                <td>好</td>
                                <td>1026</td>
                                <td class="vector-cell">[0.45, -0.21, 0.38, 0.52, -0.33, ...]</td>
                            </tr>
                            <tr>
                                <td>天气</td>
                                <td>2048</td>
                                <td class="vector-cell">[0.18, -0.37, 0.65, 0.29, -0.52, ...]</td>
                            </tr>
                            <tr>
                                <td>今天</td>
                                <td>2049</td>
                                <td class="vector-cell">[0.22, -0.48, 0.31, 0.67, -0.19, ...]</td>
                            </tr>
                            <tr>
                                <td>不错</td>
                                <td>2050</td>
                                <td class="vector-cell">[0.41, -0.29, 0.53, 0.18, -0.63, ...]</td>
                            </tr>
                            <tr>
                                <td>是的</td>
                                <td>2051</td>
                                <td class="vector-cell">[0.36, -0.44, 0.27, 0.58, -0.31, ...]</td>
                            </tr>
                            <tr>
                                <td>谢谢</td>
                                <td>2052</td>
                                <td class="vector-cell">[0.51, -0.17, 0.42, 0.33, -0.25, ...]</td>
                            </tr>
                        </tbody>
                    </table>
                    <p style="font-size: 11px; color: #666; margin-top: 10px;">注：实际的词向量通常是数百到数千维的高维向量，这里仅展示简化版本。</p>
                </div>
            </div>
        </div>
        
        <!-- 右侧面板：LLM演示 -->
        <div class="right-panel">
            <h2>大语言模型演示</h2>
            <p>输入文本，点击"开始演示"，观察AI如何逐字生成回复。</p>
            
            <div class="demo-input">
                <input type="text" id="user-input" placeholder="输入一些文字..." value="今天天气真不错">
                <button id="demo-button">开始演示</button>
            </div>
            
            <div id="chat-container" class="chat-container"></div>
        </div>
    </div>

    <script>
        // 获取元素
        const statusDisplay = document.getElementById('status-display');
        const networkPhase = document.getElementById('network-phase');
        const progressBar = document.getElementById('progress-bar');
        const pauseBtn = document.getElementById('pause-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');
        
        // 获取Canvas元素和上下文
        const canvas = document.getElementById('aiCanvas');
        const ctx = canvas.getContext('2d');
        
        // 确保canvas尺寸正确设置
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // 在获取元素后立即添加以下代码，初始化神经网络
        const colors = {
            background: '#ffffff',
            node: '#3498db',
            connection: '#bdc3c7',
            text: '#2c3e50',
            highlight: '#e74c3c'
        };
        
        // 全局变量
        let currentTokenIndex = -1;           // 当前处理的字符索引
        let currentTokenPhase = null;         // 当前处理阶段 (input, hidden1, hidden2, output, complete)
        let phaseProgress = 0;                // 当前阶段进度 (0-100)
        let animationPaused = false;          // 动画是否暂停
        let animationTimeout = null;          // 动画超时ID
        let animationSpeed = 5;               // 动画速度 (1-10)
        let vocabularyVisible = false;      // 词汇表是否可见
        
        // 初始化时立即绘制神经网络
        drawNeuralNetwork();
        
        // 定义层和节点
        function calculateLayers() {
            return [
                { name: '输入层', nodes: 4, x: canvas.width * 0.15 },
                { name: '隐藏层 1', nodes: 6, x: canvas.width * 0.35 },
                { name: '隐藏层 2', nodes: 6, x: canvas.width * 0.55 },
                { name: '输出层', nodes: 3, x: canvas.width * 0.75 }
            ];
        }
        
        // 修改drawNeuralNetwork函数，使用Transformer架构
        function drawNeuralNetwork() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 定义Transformer架构的层
            const layers = [
                { name: "输入嵌入层", nodes: 6, x: canvas.width * 0.10, description: "将文本转换为向量" },
                { name: "位置编码层", nodes: 6, x: canvas.width * 0.22, description: "添加位置信息" },
                { name: "自注意力层", nodes: 8, x: canvas.width * 0.34, description: "捕捉上下文关系" },
                { name: "前馈网络层", nodes: 8, x: canvas.width * 0.46, description: "处理特征转换" },
                { name: "归一化层", nodes: 6, x: canvas.width * 0.58, description: "稳定训练过程" },
                { name: "解码器层", nodes: 8, x: canvas.width * 0.70, description: "生成输出概率" },
                { name: "输出层", nodes: 6, x: canvas.width * 0.85, description: "预测下一个词" }
            ];
            
            // 计算节点位置
            const nodePositions = [];
            const nodeRadius = 7; // 稍微减小节点半径，以适应更多层
            const layerHeight = canvas.height * 0.5;
            
            for (let i = 0; i < layers.length; i++) {
                const layer = layers[i];
                const nodes = [];
                
                // 计算每个节点的位置
                for (let j = 0; j < layer.nodes; j++) {
                    const x = layer.x;
                    const y = (canvas.height * 0.25) + (j * (layerHeight / (layer.nodes - 1)));
                    nodes.push({ x, y });
                }
                
                nodePositions.push(nodes);
            }
            
            // 绘制连接
            ctx.strokeStyle = colors.connection;
            ctx.lineWidth = 0.5;
            
            for (let i = 0; i < nodePositions.length - 1; i++) {
                for (let j = 0; j < nodePositions[i].length; j++) {
                    for (let k = 0; k < nodePositions[i + 1].length; k++) {
                        ctx.beginPath();
                        ctx.moveTo(nodePositions[i][j].x, nodePositions[i][j].y);
                        ctx.lineTo(nodePositions[i + 1][k].x, nodePositions[i + 1][k].y);
                        ctx.stroke();
                    }
                }
            }
            
            // 绘制自注意力层的特殊连接（自连接）
            if (nodePositions.length > 2) {
                const attentionLayerIndex = 2; // 自注意力层索引
                ctx.strokeStyle = 'rgba(52, 152, 219, 0.3)'; // 淡蓝色
                ctx.lineWidth = 0.5;
                
                // 在自注意力层内部添加节点间的连接，表示自注意力
                for (let j = 0; j < nodePositions[attentionLayerIndex].length; j++) {
                    for (let k = 0; k < nodePositions[attentionLayerIndex].length; k++) {
                        if (j !== k) { // 不连接自身
                            ctx.beginPath();
                            ctx.moveTo(nodePositions[attentionLayerIndex][j].x, nodePositions[attentionLayerIndex][j].y);
                            
                            // 创建弯曲的连接线
                            const controlX = nodePositions[attentionLayerIndex][j].x + 15;
                            const controlY = (nodePositions[attentionLayerIndex][j].y + nodePositions[attentionLayerIndex][k].y) / 2;
                            
                            ctx.quadraticCurveTo(
                                controlX, controlY,
                                nodePositions[attentionLayerIndex][k].x, nodePositions[attentionLayerIndex][k].y
                            );
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // 绘制节点
            for (let i = 0; i < nodePositions.length; i++) {
                // 为不同层设置不同颜色
                if (i === 0) ctx.fillStyle = '#3498db'; // 输入嵌入层 - 蓝色
                else if (i === 1) ctx.fillStyle = '#9b59b6'; // 位置编码层 - 紫色
                else if (i === 2) ctx.fillStyle = '#e74c3c'; // 自注意力层 - 红色
                else if (i === 3) ctx.fillStyle = '#f39c12'; // 前馈网络层 - 橙色
                else if (i === 4) ctx.fillStyle = '#1abc9c'; // 归一化层 - 绿松石色
                else if (i === 5) ctx.fillStyle = '#2ecc71'; // 解码器层 - 绿色
                else if (i === 6) ctx.fillStyle = '#34495e'; // 输出层 - 深灰色
                else ctx.fillStyle = colors.node;
                
                for (let j = 0; j < nodePositions[i].length; j++) {
                    ctx.beginPath();
                    ctx.arc(nodePositions[i][j].x, nodePositions[i][j].y, nodeRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // 绘制层名称和描述
            ctx.textAlign = 'center';
            
            for (let i = 0; i < layers.length; i++) {
                // 绘制层名称
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 12px Arial';
                ctx.fillText(layers[i].name, layers[i].x, canvas.height * 0.15);
                
                // 绘制层描述
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '10px Arial';
                ctx.fillText(layers[i].description, layers[i].x, canvas.height * 0.15 + 15);
            }
            
            // 添加Transformer架构标题
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('Transformer架构', canvas.width / 2, canvas.height * 0.08);
            
            // 添加上下文显示
            if (currentTokenIndex >= 0 && globalTokens.length > 0) {
                // 显示当前上下文（用户输入 + 已生成的输出）
                const userInput = document.getElementById('user-input').value.trim();
                let generatedText = '';
                for (let i = 0; i < currentTokenIndex; i++) {
                    generatedText += globalTokens[i];
                }
                
                // 在输入层上方显示上下文
                ctx.font = '12px Arial';
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                
                // 用户输入（以蓝色显示）
                ctx.fillStyle = '#3498db';
                ctx.fillText('用户输入:', layers[0].x, canvas.height * 0.15 - 30);
                
                // 如果用户输入太长，截断显示
                const displayInput = userInput.length > 15 ? userInput.substring(0, 12) + '...' : userInput;
                ctx.fillText(`"${displayInput}"`, layers[0].x, canvas.height * 0.15 - 15);
                
                // 已生成的输出（以绿色显示）
                if (generatedText) {
                    ctx.fillStyle = '#2ecc71';
                    ctx.fillText('已生成:', layers[0].x, canvas.height * 0.85);
                    
                    // 如果已生成文本太长，截断显示
                    const displayGenerated = generatedText.length > 15 ? generatedText.substring(generatedText.length - 12) + '...' : generatedText;
                    ctx.fillText(`"${displayGenerated}"`, layers[0].x, canvas.height * 0.85 + 15);
                }
                
                // 在输出层上方显示当前正在生成的字符
                if (currentTokenPhase === 'output' || currentTokenPhase === 'complete') {
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillText('当前生成:', layers[6].x, canvas.height * 0.85);
                    ctx.font = '16px Arial';
                    ctx.fillText(globalTokens[currentTokenIndex], layers[6].x, canvas.height * 0.85 + 20);
                }
            }
            
            // 绘制从输出到输入的反馈箭头
            drawArrow(
                layers[6].x, canvas.height * 0.7, // 从输出层下方开始
                layers[0].x, canvas.height * 0.7, // 到输入层下方
                '#3498db', // 使用与神经节点相同的蓝色
                true // 标记为反馈箭头
            );
            
            return { layers, nodePositions, nodeRadius };
        }
        
        // 绘制激活的节点
        function drawActiveNode(x, y, radius) {
            ctx.fillStyle = colors.highlight;
            ctx.beginPath();
            ctx.arc(x, y, radius + 3, 0, Math.PI * 2);
            ctx.fill();
            
            // 添加光晕效果
            ctx.strokeStyle = colors.highlight;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(x, y, radius + 6, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // 绘制激活的连接
        function drawActiveConnection(x1, y1, x2, y2) {
            ctx.strokeStyle = colors.highlight;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
        
        // 绘制箭头
        function drawArrow(fromX, fromY, toX, toY, color, isFeedback = false) {
            // 绘制线条
            ctx.strokeStyle = isFeedback ? '#3498db' : color; // 使用与神经节点相同的蓝色
            ctx.lineWidth = isFeedback ? 3 : 2; // 反馈箭头更粗
            
            // 保存当前上下文状态
            ctx.save();
            
            // 如果是反馈箭头，添加阴影效果
            if (isFeedback) {
                ctx.shadowColor = '#3498db';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }
            
            // 绘制90度弯曲的线条
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            
            // 如果是反馈箭头，创建90度弯曲
            if (isFeedback) {
                // 先向下，再向左
                const midY = fromY + 50; // 向下延伸50像素
                ctx.lineTo(fromX, midY); // 垂直向下
                ctx.lineTo(toX, midY);   // 水平向左
                ctx.lineTo(toX, toY);    // 垂直向上
            } else {
                // 普通箭头直接连接
                ctx.lineTo(toX, toY);
            }
            
            ctx.stroke();
            
            // 绘制箭头头部
            let angle;
            if (isFeedback) {
                // 如果是反馈箭头，箭头方向向上
                angle = -Math.PI/2; // 向上的角度
            } else {
                // 普通箭头，计算角度
                angle = Math.atan2(toY - fromY, toX - fromX);
            }
            
            const arrowSize = isFeedback ? 12 : 10; // 反馈箭头箭头更大
            
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(
                toX - arrowSize * Math.cos(angle - Math.PI / 6),
                toY - arrowSize * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                toX - arrowSize * Math.cos(angle + Math.PI / 6),
                toY - arrowSize * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fillStyle = isFeedback ? '#3498db' : color;
            ctx.fill();
            
            // 恢复上下文状态
            ctx.restore();
            
            // 如果是反馈箭头，添加标签
            if (isFeedback) {
                ctx.fillStyle = '#3498db';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                // 将文字放在水平线段上方
                const textX = (fromX + toX) / 2;
                const textY = fromY + 50 - 15; // 水平线段上方15像素
                ctx.fillText('反馈学习', textX, textY);
            }
        }
        
        // 修改simulateNetworkActivation函数，适应Transformer架构
        function simulateNetworkActivation() {
            // 重绘基本网络
            const networkData = drawNeuralNetwork();
            const { layers, nodePositions, nodeRadius } = networkData;
            
            // 如果没有正在处理的字符，直接返回
            if (currentTokenIndex < 0 || currentTokenIndex >= globalTokens.length || currentTokenPhase === null) {
                return;
            }
            
            // 更新阶段描述
            updatePhaseDescription();
            
            // 根据当前阶段激活相应的节点和连接
            switch (currentTokenPhase) {
                case 'input':
                    // 输入嵌入层激活
                    const activeInputNodes = Math.ceil(nodePositions[0].length * (phaseProgress / 100));
                    for (let i = 0; i < activeInputNodes; i++) {
                        drawActiveNode(nodePositions[0][i].x, nodePositions[0][i].y, nodeRadius);
                    }
                    
                    // 如果进度超过50%，开始激活到位置编码层的连接
                    if (phaseProgress > 50) {
                        const activeConnections = Math.ceil(nodePositions[0].length * ((phaseProgress - 50) / 50));
                        for (let i = 0; i < activeConnections; i++) {
                            for (let j = 0; j < nodePositions[1].length; j++) {
                                drawActiveConnection(
                                    nodePositions[0][i].x, nodePositions[0][i].y,
                                    nodePositions[1][j].x, nodePositions[1][j].y
                                );
                            }
                        }
                    }
                    break;
                    
                case 'hidden1':
                    // 输入嵌入层保持激活
                    for (let i = 0; i < nodePositions[0].length; i++) {
                        drawActiveNode(nodePositions[0][i].x, nodePositions[0][i].y, nodeRadius);
                    }
                    
                    // 输入嵌入层到位置编码层的连接保持激活
                    for (let i = 0; i < nodePositions[0].length; i++) {
                        for (let j = 0; j < nodePositions[1].length; j++) {
                            drawActiveConnection(
                                nodePositions[0][i].x, nodePositions[0][i].y,
                                nodePositions[1][j].x, nodePositions[1][j].y
                            );
                        }
                    }
                    
                    // 位置编码层激活
                    const activePosNodes = Math.ceil(nodePositions[1].length * (phaseProgress / 33));
                    for (let i = 0; i < activePosNodes; i++) {
                        drawActiveNode(nodePositions[1][i].x, nodePositions[1][i].y, nodeRadius);
                    }
                    
                    // 位置编码层到自注意力层的连接激活
                    if (phaseProgress > 33) {
                        const attentionProgress = phaseProgress - 33;
                        const activeAttConnections = Math.ceil(nodePositions[1].length * (attentionProgress / 33));
                        for (let i = 0; i < activeAttConnections; i++) {
                            for (let j = 0; j < nodePositions[2].length; j++) {
                                drawActiveConnection(
                                    nodePositions[1][i].x, nodePositions[1][i].y,
                                    nodePositions[2][j].x, nodePositions[2][j].y
                                );
                            }
                        }
                    }
                    
                    // 自注意力层节点激活
                    if (phaseProgress > 66) {
                        const attNodeProgress = phaseProgress - 66;
                        const activeAttNodes = Math.ceil(nodePositions[2].length * (attNodeProgress / 34));
                        for (let i = 0; i < activeAttNodes; i++) {
                            drawActiveNode(nodePositions[2][i].x, nodePositions[2][i].y, nodeRadius);
                        }
                        
                        // 自注意力层内部连接激活
                        if (activeAttNodes > 1) {
                            ctx.strokeStyle = 'rgba(231, 76, 60, 0.8)'; // 鲜红色
                            ctx.lineWidth = 1;
                            
                            for (let j = 0; j < activeAttNodes; j++) {
                                for (let k = 0; k < activeAttNodes; k++) {
                                    if (j !== k) { // 不连接自身
                                        ctx.beginPath();
                                        ctx.moveTo(nodePositions[2][j].x, nodePositions[2][j].y);
                                        
                                        // 创建弯曲的连接线
                                        const controlX = nodePositions[2][j].x + 15;
                                        const controlY = (nodePositions[2][j].y + nodePositions[2][k].y) / 2;
                                        
                                        ctx.quadraticCurveTo(
                                            controlX, controlY,
                                            nodePositions[2][k].x, nodePositions[2][k].y
                                        );
                                        ctx.stroke();
                                    }
                                }
                            }
                        }
                    }
                    break;
                    
                case 'hidden2':
                    // 前面的层保持激活
                    for (let i = 0; i < 3; i++) { // 输入嵌入层、位置编码层、自注意力层
                        for (let j = 0; j < nodePositions[i].length; j++) {
                            drawActiveNode(nodePositions[i][j].x, nodePositions[i][j].y, nodeRadius);
                        }
                    }
                    
                    // 前面层间的连接保持激活
                    for (let i = 0; i < 2; i++) { // 输入→位置编码→自注意力
                        for (let j = 0; j < nodePositions[i].length; j++) {
                            for (let k = 0; k < nodePositions[i + 1].length; k++) {
                                drawActiveConnection(
                                    nodePositions[i][j].x, nodePositions[i][j].y,
                                    nodePositions[i + 1][k].x, nodePositions[i + 1][k].y
                                );
                            }
                        }
                    }
                    
                    // 自注意力层内部的连接保持激活
                    ctx.strokeStyle = 'rgba(231, 76, 60, 0.8)'; // 鲜红色
                    ctx.lineWidth = 1;
                    
                    for (let j = 0; j < nodePositions[2].length; j++) {
                        for (let k = 0; k < nodePositions[2].length; k++) {
                            if (j !== k) { // 不连接自身
                                ctx.beginPath();
                                ctx.moveTo(nodePositions[2][j].x, nodePositions[2][j].y);
                                
                                // 创建弯曲的连接线
                                const controlX = nodePositions[2][j].x + 15;
                                const controlY = (nodePositions[2][j].y + nodePositions[2][k].y) / 2;
                                
                                ctx.quadraticCurveTo(
                                    controlX, controlY,
                                    nodePositions[2][k].x, nodePositions[2][k].y
                                );
                                ctx.stroke();
                            }
                        }
                    }
                    
                    // 自注意力层到前馈网络层的连接激活
                    const activeFeedConnections = Math.ceil(nodePositions[2].length * (phaseProgress / 33));
                    for (let i = 0; i < activeFeedConnections; i++) {
                        for (let j = 0; j < nodePositions[3].length; j++) {
                            drawActiveConnection(
                                nodePositions[2][i].x, nodePositions[2][i].y,
                                nodePositions[3][j].x, nodePositions[3][j].y
                            );
                        }
                    }
                    
                    // 前馈网络层节点激活
                    if (phaseProgress > 33) {
                        const feedProgress = phaseProgress - 33;
                        const activeFeedNodes = Math.ceil(nodePositions[3].length * (feedProgress / 33));
                        for (let i = 0; i < activeFeedNodes; i++) {
                            drawActiveNode(nodePositions[3][i].x, nodePositions[3][i].y, nodeRadius);
                        }
                    }
                    
                    // 前馈网络层到归一化层的连接激活
                    if (phaseProgress > 66) {
                        const normProgress = phaseProgress - 66;
                        const activeNormConnections = Math.ceil(nodePositions[3].length * (normProgress / 34));
                        for (let i = 0; i < activeNormConnections; i++) {
                            for (let j = 0; j < nodePositions[4].length; j++) {
                                drawActiveConnection(
                                    nodePositions[3][i].x, nodePositions[3][i].y,
                                    nodePositions[4][j].x, nodePositions[4][j].y
                                );
                            }
                        }
                        
                        // 归一化层节点激活
                        const activeNormNodes = Math.ceil(nodePositions[4].length * (normProgress / 34));
                        for (let i = 0; i < activeNormNodes; i++) {
                            drawActiveNode(nodePositions[4][i].x, nodePositions[4][i].y, nodeRadius);
                        }
                    }
                    break;
                    
                case 'output':
                    // 解码器层和输出层激活
                    
                    // 所有前面的层保持激活
                    for (let i = 0; i < 5; i++) { // 输入嵌入层到归一化层
                        for (let j = 0; j < nodePositions[i].length; j++) {
                            drawActiveNode(nodePositions[i][j].x, nodePositions[i][j].y, nodeRadius);
                        }
                    }
                    
                    // 所有前面层间的连接保持激活
                    for (let i = 0; i < 4; i++) { // 输入→位置编码→自注意力→前馈→归一化
                        for (let j = 0; j < nodePositions[i].length; j++) {
                            for (let k = 0; k < nodePositions[i + 1].length; k++) {
                                drawActiveConnection(
                                    nodePositions[i][j].x, nodePositions[i][j].y,
                                    nodePositions[i + 1][k].x, nodePositions[i + 1][k].y
                                );
                            }
                        }
                    }
                    
                    // 自注意力层内部的连接保持激活
                    ctx.strokeStyle = 'rgba(231, 76, 60, 0.8)'; // 鲜红色
                    ctx.lineWidth = 1;
                    
                    for (let j = 0; j < nodePositions[2].length; j++) {
                        for (let k = 0; k < nodePositions[2].length; k++) {
                            if (j !== k) { // 不连接自身
                                ctx.beginPath();
                                ctx.moveTo(nodePositions[2][j].x, nodePositions[2][j].y);
                                
                                // 创建弯曲的连接线
                                const controlX = nodePositions[2][j].x + 15;
                                const controlY = (nodePositions[2][j].y + nodePositions[2][k].y) / 2;
                                
                                ctx.quadraticCurveTo(
                                    controlX, controlY,
                                    nodePositions[2][k].x, nodePositions[2][k].y
                                );
                                ctx.stroke();
                            }
                        }
                    }
                    
                    // 归一化层到解码器层的连接激活
                    const activeDecoderConnections = Math.ceil(nodePositions[4].length * (phaseProgress / 33));
                    for (let i = 0; i < activeDecoderConnections && i < nodePositions[4].length; i++) {
                        for (let j = 0; j < nodePositions[5].length; j++) {
                            drawActiveConnection(
                                nodePositions[4][i].x, nodePositions[4][i].y,
                                nodePositions[5][j].x, nodePositions[5][j].y
                            );
                        }
                    }
                    
                    // 解码器层节点激活
                    if (phaseProgress > 33) {
                        const decoderProgress = phaseProgress - 33;
                        const activeDecoderNodes = Math.ceil(nodePositions[5].length * (decoderProgress / 33));
                        for (let i = 0; i < activeDecoderNodes && i < nodePositions[5].length; i++) {
                            drawActiveNode(nodePositions[5][i].x, nodePositions[5][i].y, nodeRadius);
                        }
                    }
                    
                    // 解码器层到输出层的连接激活
                    if (phaseProgress > 66) {
                        const outputProgress = phaseProgress - 66;
                        const activeOutputConnections = Math.ceil(nodePositions[5].length * (outputProgress / 34));
                        for (let i = 0; i < activeOutputConnections && i < nodePositions[5].length; i++) {
                            for (let j = 0; j < nodePositions[6].length; j++) {
                                drawActiveConnection(
                                    nodePositions[5][i].x, nodePositions[5][i].y,
                                    nodePositions[6][j].x, nodePositions[6][j].y
                                );
                            }
                        }
                        
                        // 输出层节点激活
                        const activeOutputNodes = Math.ceil(nodePositions[6].length * (outputProgress / 34));
                        for (let i = 0; i < activeOutputNodes && i < nodePositions[6].length; i++) {
                            drawActiveNode(nodePositions[6][i].x, nodePositions[6][i].y, nodeRadius);
                        }
                    }
                    
                    // 更新词汇表显示
                    updateVocabularyDisplay();
                    break;
                    
                case 'complete':
                    // 所有层全部激活
                    for (let i = 0; i < nodePositions.length; i++) {
                        for (let j = 0; j < nodePositions[i].length; j++) {
                            drawActiveNode(nodePositions[i][j].x, nodePositions[i][j].y, nodeRadius);
                            
                            // 激活到下一层的连接
                            if (i < nodePositions.length - 1) {
                                for (let k = 0; k < nodePositions[i + 1].length; k++) {
                                    drawActiveConnection(
                                        nodePositions[i][j].x, nodePositions[i][j].y,
                                        nodePositions[i + 1][k].x, nodePositions[i + 1][k].y
                                    );
                                }
                            }
                        }
                    }
                    
                    // 自注意力层内部的连接保持激活
                    ctx.strokeStyle = 'rgba(231, 76, 60, 0.8)'; // 鲜红色
                    ctx.lineWidth = 1;
                    
                    for (let j = 0; j < nodePositions[2].length; j++) {
                        for (let k = 0; k < nodePositions[2].length; k++) {
                            if (j !== k) { // 不连接自身
                                ctx.beginPath();
                                ctx.moveTo(nodePositions[2][j].x, nodePositions[2][j].y);
                                
                                // 创建弯曲的连接线
                                const controlX = nodePositions[2][j].x + 15;
                                const controlY = (nodePositions[2][j].y + nodePositions[2][k].y) / 2;
                                
                                ctx.quadraticCurveTo(
                                    controlX, controlY,
                                    nodePositions[2][k].x, nodePositions[2][k].y
                                );
                                ctx.stroke();
                            }
                        }
                    }
                    
                    // 更新词汇表显示
                    updateVocabularyDisplay();
                    
                    // 如果不是最后一个token，显示自回归循环
                    if (currentTokenIndex < globalTokens.length - 1 && phaseProgress > 50) {
                        // 在输出层下方添加"预测下一个token"的文本
                        ctx.fillStyle = colors.highlight;
                        ctx.font = 'bold 12px Arial';
                        ctx.fillText("将生成的字符添加到上下文", canvas.width / 2, canvas.height - 40);
                        
                        // 添加从输出到下一个输入的箭头，表示循环
                        drawArrow(layers[6].x + 30, canvas.height * 0.4, layers[0].x - 20, canvas.height * 0.4, colors.highlight, false);
                        
                        // 添加自回归说明
                        ctx.fillStyle = colors.highlight;
                        ctx.font = '12px Arial';
                        ctx.fillText("自回归: 已生成的内容成为新的输入", canvas.width / 2, canvas.height - 20);
                        
                        // 在输出层右侧显示下一个要生成的字符位置
                        if (phaseProgress > 80) {
                            ctx.fillStyle = '#999';
                            ctx.font = '14px Arial';
                            ctx.fillText("?", layers[6].x + 30, canvas.height * 0.3);
                            ctx.fillText("(下一个字符)", layers[6].x + 30, canvas.height * 0.3 + 20);
                        }
                    }
                    break;
            }
            
            // 更新进度条
            updateProgressBar();
        }
        
        // 修改updatePhaseDescription函数，适应Transformer架构
        function updatePhaseDescription() {
            const phaseDisplay = document.getElementById('network-phase');
            
            if (!phaseDisplay || currentTokenPhase === null) return;
            
            let phaseText = '';
            
            switch (currentTokenPhase) {
                case 'input':
                    phaseText = `输入嵌入阶段 (${phaseProgress}%): 将文本转换为向量表示`;
                    break;
                case 'hidden1':
                    phaseText = `注意力机制阶段 (${phaseProgress}%): 捕捉上下文关系`;
                    break;
                case 'hidden2':
                    phaseText = `特征处理阶段 (${phaseProgress}%): 通过前馈网络和归一化处理特征`;
                    break;
                case 'output':
                    phaseText = `生成阶段 (${phaseProgress}%): 计算词汇表概率分布`;
                    break;
                case 'complete':
                    phaseText = `完成阶段 (${phaseProgress}%): 输出当前字符，准备下一个预测`;
                    break;
            }
            
            phaseDisplay.textContent = phaseText;
        }
        
        // 获取每个阶段的权重（用于计算总进度）
        function getPhaseWeight(phase) {
            switch (phase) {
                case 'input': return 0.0;
                case 'hidden1': return 0.25;
                case 'hidden2': return 0.5;
                case 'output': return 0.75;
                case 'complete': return 1.0;
                default: return 0;
            }
        }
        
        // 获取下一个阶段
        function getNextPhase(phase) {
            switch (phase) {
                case 'input': return 'hidden1';
                case 'hidden1': return 'hidden2';
                case 'hidden2': return 'output';
                case 'output': return 'complete';
                case 'complete': return null;
                default: return null;
            }
        }
        
        // 更新进度条
        function updateProgressBar() {
            // 计算总体进度
            let totalProgress = 0;
            if (currentTokenIndex >= 0) {
                // 基础进度：已完成的字符 / 总字符数
                const baseProgress = currentTokenIndex / globalTokens.length;
                
                // 当前字符的进度贡献
                if (currentTokenPhase !== null) {
                    const phaseBaseWeight = getPhaseWeight(currentTokenPhase);
                    const nextPhase = getNextPhase(currentTokenPhase);
                    const nextWeight = nextPhase ? getPhaseWeight(nextPhase) : 1.0;
                    const phaseContribution = (phaseProgress / 100) * (nextWeight - phaseBaseWeight);
                    
                    // 当前字符的总贡献 = 已完成阶段的基础权重 + 当前阶段的部分贡献
                    const currentTokenContribution = phaseBaseWeight + phaseContribution;
                    
                    // 当前字符对总进度的贡献
                    const currentCharProgress = currentTokenContribution / globalTokens.length;
                    
                    // 总进度 = 已完成字符的进度 + 当前字符的进度
                    totalProgress = baseProgress + currentCharProgress;
                } else {
                    totalProgress = baseProgress;
                }
            }
            
            // 更新进度条
            progressBar.style.width = `${totalProgress * 100}%`;
        }
        
        // 动画控制变量
        globalTokens = [];          // 存储所有要生成的字符
        currentTokenIndex = -1;     // 当前正在处理的字符索引
        currentTokenPhase = null;   // 当前处理阶段 (input, hidden1, hidden2, output, complete)
        phaseProgress = 0;          // 当前阶段的进度 (0-100)
        animationPaused = false;    // 动画是否暂停
        animationTimeout = null;    // 存储setTimeout的ID，用于暂停
        animationSpeed = 5;         // 动画速度 (1-10)
        
        // 继续动画的函数（用于暂停后恢复）
        function continueAnimation() {
            if (!animationPaused) {
                advancePhase();
            }
        }
        
        // 推进动画阶段
        function advancePhase() {
            if (animationPaused) return;
            
            // 如果当前没有阶段或上一个阶段已完成，进入下一个阶段
            if (currentTokenPhase === null || phaseProgress >= 100) {
                switch (currentTokenPhase) {
                    case null:
                        currentTokenPhase = 'input';
                        phaseProgress = 0;
                        break;
                    case 'input':
                        currentTokenPhase = 'hidden1';
                        phaseProgress = 0;
                        break;
                    case 'hidden1':
                        currentTokenPhase = 'hidden2';
                        phaseProgress = 0;
                        break;
                    case 'hidden2':
                        currentTokenPhase = 'output';
                        phaseProgress = 0;
                        break;
                    case 'output':
                        currentTokenPhase = 'complete';
                        phaseProgress = 0;
                        break;
                    case 'complete':
                        // 当前字符处理完成，输出字符并准备处理下一个字符
                        outputCurrentToken();
                        currentTokenIndex++;
                        
                        if (currentTokenIndex < globalTokens.length) {
                            // 还有更多字符要处理
                            currentTokenPhase = 'input';
                            phaseProgress = 0;
                        } else {
                            // 所有字符都处理完成
                            currentTokenPhase = null;
                            statusDisplay.textContent = "生成完成！";
                            document.getElementById('demo-button').disabled = false;
                            pauseBtn.disabled = true;
                            resumeBtn.disabled = true;
                            return; // 结束递归
                        }
                        break;
                }
            } else {
                // 在当前阶段内推进进度
                phaseProgress += animationSpeed; // 速度值越大，每次增加的进度越多，播放越快
                if (phaseProgress > 100) phaseProgress = 100;
            }
            
            // 更新可视化
            simulateNetworkActivation();
            
            // 递归调用自身，创建动画循环
            const delay = 100; // 基础延迟
            animationTimeout = setTimeout(advancePhase, delay);
        }
        
        // 输出当前token到AI消息
        function outputCurrentToken() {
            if (currentTokenIndex < 0 || currentTokenIndex >= globalTokens.length) return;
            
            const aiMessage = document.querySelector('.ai-message');
            if (!aiMessage) return;
            
            // 获取现有文本内容
            let outputText = aiMessage.textContent || '';
            
            // 添加新字符
            outputText += globalTokens[currentTokenIndex];
            
            // 更新消息内容
            aiMessage.innerHTML = '';
            aiMessage.textContent = outputText;
            
            // 添加光标
            const cursor = document.createElement('span');
            cursor.className = 'cursor';
            aiMessage.appendChild(cursor);
            
            // 自动滚动到底部
            const chatContainer = document.getElementById('chat-container');
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
        
        // LLM演示相关代码
        document.getElementById('demo-button').addEventListener('click', function() {
            const userInput = document.getElementById('user-input').value.trim();
            if (!userInput) {
                alert("请输入一些文字再开始演示");
                return;
            }
            
            // 禁用按钮，防止重复点击
            document.getElementById('demo-button').disabled = true;
            
            // 清空之前的聊天
            const chatContainer = document.getElementById('chat-container');
            chatContainer.innerHTML = '';
            
            // 添加用户消息
            const userMessage = document.createElement('div');
            userMessage.className = 'user-message';
            userMessage.textContent = userInput;
            chatContainer.appendChild(userMessage);
            
            // 添加AI消息框
            const aiMessage = document.createElement('div');
            aiMessage.className = 'ai-message';
            chatContainer.appendChild(aiMessage);
            
            // 生成回复内容（这里根据用户输入简单生成回复）
            let response = '';
            if (userInput.includes('天气')) {
                response = "是的，今天的天气确实很好。阳光明媚，温度适宜，非常适合户外活动。您有什么户外计划吗？";
            } else if (userInput.includes('你好') || userInput.includes('您好')) {
                response = "你好！很高兴见到你。我是一个AI助手，有什么我可以帮助你的吗？";
            } else if (userInput.includes('介绍') || userInput.includes('是什么')) {
                response = "我是一个基于深度学习的语言模型，通过分析大量文本数据训练而成。我可以理解和生成文本，回答问题，甚至创作内容。";
            } else {
                response = "我理解您的输入是：\"" + userInput + "\"。作为一个AI助手，我总是尽力提供有用的回应。您还有其他问题吗？";
            }
            
            // 添加思考动画
            const thinking = document.createElement('div');
            thinking.className = 'thinking-animation';
            thinking.textContent = '思考中...';
            aiMessage.appendChild(thinking);
            
            // 更新状态显示
            statusDisplay.textContent = "AI正在分析输入...";
            
            // 将回复分割成字符
            globalTokens = [];
            for (let i = 0; i < response.length; i++) {
                globalTokens.push(response[i]);
            }
            
            // 重置动画状态
            currentTokenIndex = -1;
            currentTokenPhase = null;
            phaseProgress = 0;
            animationPaused = false;
            
            // 清除可能存在的超时
            if (animationTimeout) {
                clearTimeout(animationTimeout);
            }
            
            // 启用控制按钮
            pauseBtn.disabled = false;
            resumeBtn.disabled = true;
            
            // 延迟1.5秒后开始处理，模拟思考过程
            setTimeout(() => {
                aiMessage.innerHTML = '';
                currentTokenIndex = 0;
                currentTokenPhase = null;
                
                statusDisplay.textContent = "开始生成回复...";
                
                // 初始化动画控制变量
                animationPaused = false;
                
                // 开始动画
                advancePhase();
            }, 1500);
        });
        
        // 速度滑动条事件处理
        speedSlider.addEventListener('input', function() {
            animationSpeed = parseInt(this.value);
            speedValue.textContent = animationSpeed;
        });
        
        // 暂停和继续按钮事件处理
        pauseBtn.addEventListener('click', function() {
            if (animationTimeout) {
                clearTimeout(animationTimeout);
                animationTimeout = null;
            }
            animationPaused = true;
            pauseBtn.disabled = true;
            resumeBtn.disabled = false;
        });
        
        resumeBtn.addEventListener('click', function() {
            animationPaused = false;
            pauseBtn.disabled = false;
            resumeBtn.disabled = true;
            continueAnimation();
        });
        
        // 初始化
        speedValue.textContent = animationSpeed;
        
        // 添加生成概率分布的函数
        function generateProbabilityDistribution(currentChar) {
            // 创建一个模拟的词汇表和概率分布
            // 在实际的LLM中，这是基于模型计算的概率分布
            const tokenProbabilities = [];
            
            // 为当前字符设置最高概率
            tokenProbabilities.push({
                token: currentChar,
                probability: 0.6 + Math.random() * 0.3, // 60-90%的概率
                selected: true
            });
            
            // 添加一些随机的候选字符
            const possibleChars = "的一是了我不人在他有这个上们来到时大地为子中你说生国年着就那和要她出也得里后自以会家可下而过天去能对小多然于心学么之都好看起发当没成只如事把还用第样道想作种开美总从无情己面最女但现前些所同日手又行意动方期它头经长儿回位分爱老因很给名法间斯知世什两次使身者被高已亲其进此话常与活正感见明问力理尔点文几定本公特做外孩相西果走将月十实向声车全信重三机工物气每并别真打太新比才便夫再书部水像眼等体却加电主界门利海受听表德少克代员许稜先口由死安写性马光白或住难望教命花结乐色更拉东神记处让母父应直字场平报友关放至张认接告入笑内英军候民岁往何度山觉路带万男边风解叫任金快原吃妈变通师立象数四失满战远格士音轻目条呢病始达深完今提求清王化空业思切怎非找片罗钱紶吗语元喜曾离飞科言干流欢约各即指合反题必该论交终林请医晚制球决窢传画保读运及则房早院量苦火布品近坐产答星精视五连司巴奇管类未朋且婚台夜青北队久乎越观落尽形影红爸百令周吧识步希亚术留市半热送兴造谈容极随演收首根讲整式取照办强石古华諣拿计您装似足双妻尼转诉米称丽客南领节衣站黑刻统断福城故历惊脸选包紧争另建维绝树系伤示愿持千史谁准联妇纪基买志静阿诗独复痛消社算义竟确酒需单治卡幸兰念举仅钟怕共毛句息功官待究跟穿室易游程号居考突皮哪费倒价图具刚脑永歌响商礼细专黄块脚味灵改据般破引食仍存众注笔甚某沉血备习校默务土微娘须试怀料调广蜖苏显赛查密议底列富梦错座参八除跑亮假印设线温虽掉京初养香停际致阳纸李纳验助激够严证帝饭忘趣支春集丈木研班普导顿睡展跳获艺六波察群皇段急庭创区奥器谢弟店否害草排背止组州朝封睛板角况曲馆育忙质河续哥呼若推境遇雨标姐充围案伦护冷警贝著雪索剧啊船险烟依斗值帮汉慢佛肯闻唱沙局伯族低玩资屋击速顾泪洲团圣旁堂兵七露园牛哭旅街劳型烈姑陈莫鱼异抱宝权鲁简态级票怪寻杀律胜份汽右洋范床舞秘午登楼贵吸责例追较职属渐左录丝牙党继托赶章智冲叶胡吉卖坚喝肉遗救修松临藏担戏善卫药悲敢靠伊村戴词森耳差短祖云规窗散迷油旧适乡架恩投弹铁博雷府压超负勒杂醒洗采毫嘴毕九冰既状乱景席珍童顶派素脱农疑练野按犯拍征坏骨余承置臓彩灯巨琴免环姆暗换技翻束增忍餐洛塞缺忆判欧层付阵玛批岛项狗休懂武革良恶恋委拥娜妙探呀营退摇弄桌熟诺宣银势奖宫忽套康供优课鸟喊降夏困刘罪亡鞋健模败伴守挥鲜财孤枪禁恐伙杰迹妹藸遍盖副坦牌江顺秋萨菜划授归浪听凡预奶雄升碃编典袋莱含盛济蒙棋端腿招释介烧误乾坤";
            
            // 添加5-8个随机候选字符
            const numCandidates = 5 + Math.floor(Math.random() * 4);
            for (let i = 0; i < numCandidates; i++) {
                const randomChar = possibleChars.charAt(Math.floor(Math.random() * possibleChars.length));
                // 确保不重复
                if (!tokenProbabilities.some(item => item.token === randomChar)) {
                    tokenProbabilities.push({
                        token: randomChar,
                        probability: Math.random() * 0.3, // 0-30%的概率
                        selected: false
                    });
                }
            }
            
            // 按概率降序排序
            tokenProbabilities.sort((a, b) => b.probability - a.probability);
            
            return tokenProbabilities;
        }
        
        // 更新词汇表显示
        function updateVocabularyDisplay() {
            const vocabularyContainer = document.getElementById('vocabulary-container');
            const tokenProbabilitiesContainer = document.getElementById('token-probabilities');
            
            // 如果不在输出阶段或完成阶段，显示提示信息
            if (currentTokenPhase !== 'output' && currentTokenPhase !== 'complete') {
                // 清空之前的内容
                tokenProbabilitiesContainer.innerHTML = '<div style="text-align: center; margin-top: 50px; color: #999;">等待输出阶段...</div>';
                return;
            }
            
            // 清空之前的内容
            tokenProbabilitiesContainer.innerHTML = '';
            
            // 如果没有当前token，返回
            if (currentTokenIndex < 0 || currentTokenIndex >= globalTokens.length) return;
            
            // 获取当前字符
            const currentChar = globalTokens[currentTokenIndex];
            
            // 添加当前处理的字符信息
            const currentTokenInfo = document.createElement('div');
            currentTokenInfo.style.textAlign = 'center';
            currentTokenInfo.style.margin = '10px 0 20px';
            currentTokenInfo.style.fontWeight = 'bold';
            currentTokenInfo.innerHTML = `当前生成: <span style="color: #e74c3c; font-size: 18px;">${currentChar}</span>`;
            tokenProbabilitiesContainer.appendChild(currentTokenInfo);
            
            // 生成概率分布
            const probabilities = generateProbabilityDistribution(currentChar);
            
            // 创建概率条
            probabilities.forEach(item => {
                const tokenProbability = document.createElement('div');
                tokenProbability.className = 'token-probability';
                
                const token = document.createElement('div');
                token.className = 'token' + (item.selected ? ' selected-token' : '');
                token.textContent = item.token;
                
                const barContainer = document.createElement('div');
                barContainer.style.width = '200px';
                barContainer.style.backgroundColor = '#eee';
                barContainer.style.borderRadius = '3px';
                
                const bar = document.createElement('div');
                bar.className = 'probability-bar';
                bar.style.width = `${item.probability * 100}%`;
                
                const value = document.createElement('div');
                value.className = 'probability-value';
                value.textContent = `${(item.probability * 100).toFixed(1)}%`;
                
                barContainer.appendChild(bar);
                tokenProbability.appendChild(token);
                tokenProbability.appendChild(barContainer);
                tokenProbability.appendChild(value);
                
                tokenProbabilitiesContainer.appendChild(tokenProbability);
            });
        }
        
        // 在页面加载时初始化词汇表显示
        document.addEventListener('DOMContentLoaded', function() {
            // 初始化词汇表显示
            const tokenProbabilitiesContainer = document.getElementById('token-probabilities');
            tokenProbabilitiesContainer.innerHTML = '<div style="text-align: center; margin-top: 50px; color: #999;">等待演示开始...</div>';
        });
    </script>
</body>
</html>